/**
 * Export pre-colored character sprites to PNG files.
 *
 * Generates 6 PNG files (one per palette) in
 * webview-ui/public/assets/characters/. Each PNG is 336×192:
 *   - 7 frames horizontally (48px each) = 336px wide
 *   - 3 direction rows vertically (64px each) = 192px tall
 *     Row 0 = down, Row 1 = up, Row 2 = right
 *
 * Frame order per row: walk1, walk2, walk3, type1, type2, read1, read2
 *
 * Colors are baked in from CHARACTER_PALETTES — no template swapping at runtime.
 * Left-facing sprites are still generated by flipping right at runtime.
 *
 * Run: npx tsx scripts/export-characters.ts
 */

import * as fs from 'fs'
import * as path from 'path'
import { PNG } from 'pngjs'
import { CHARACTER_TEMPLATES, CHARACTER_PALETTES } from '../webview-ui/src/office/sprites/spriteData.js'

const FRAME_W = 48
const FRAME_H = 64
const SPRITE_H = 24 // actual template height — bottom-aligned in frame
const FRAMES_PER_ROW = 7
const DIRECTIONS = ['down', 'up', 'right'] as const

/** Template cell → palette key mapping */
const TEMPLATE_CELL_MAP: Record<string, 'hair' | 'skin' | 'shirt' | 'pants' | 'shoes'> = {
  'hair': 'hair',
  'skin': 'skin',
  'shirt': 'shirt',
  'pants': 'pants',
  'shoes': 'shoes',
}

/** Parse a hex color string like '#RRGGBB' into [r, g, b] */
function hexToRgb(hex: string): [number, number, number] {
  const r = parseInt(hex.slice(1, 3), 16)
  const g = parseInt(hex.slice(3, 5), 16)
  const b = parseInt(hex.slice(5, 7), 16)
  return [r, g, b]
}

function buildCharacterPng(
  paletteIndex: number,
): Buffer {
  const pal = CHARACTER_PALETTES[paletteIndex]
  const width = FRAME_W * FRAMES_PER_ROW  // 144
  const height = FRAME_H * DIRECTIONS.length  // 96
  const png = new PNG({ width, height })

  const padTop = FRAME_H - SPRITE_H // 8px transparent padding at top of each frame

  for (let dirIdx = 0; dirIdx < DIRECTIONS.length; dirIdx++) {
    const dir = DIRECTIONS[dirIdx]
    const frames = CHARACTER_TEMPLATES[dir]
    const rowOffsetY = dirIdx * FRAME_H

    for (let f = 0; f < frames.length; f++) {
      const frame = frames[f]
      const frameOffsetX = f * FRAME_W

      for (let y = 0; y < SPRITE_H; y++) {
        const row = frame[y]
        if (!row) continue
        for (let x = 0; x < FRAME_W; x++) {
          const cell = row[x]
          const idx = (((rowOffsetY + padTop + y) * width) + (frameOffsetX + x)) * 4

          if (!cell || cell === '') {
            // Transparent
            png.data[idx] = 0
            png.data[idx + 1] = 0
            png.data[idx + 2] = 0
            png.data[idx + 3] = 0
          } else {
            const paletteKey = TEMPLATE_CELL_MAP[cell]
            if (paletteKey) {
              // Resolve palette color
              const [r, g, b] = hexToRgb(pal[paletteKey])
              png.data[idx] = r
              png.data[idx + 1] = g
              png.data[idx + 2] = b
              png.data[idx + 3] = 0xFF
            } else {
              // Direct color (eyes = #FFFFFF, etc.)
              const [r, g, b] = hexToRgb(cell)
              png.data[idx] = r
              png.data[idx + 1] = g
              png.data[idx + 2] = b
              png.data[idx + 3] = 0xFF
            }
          }
        }
      }
    }
  }

  return PNG.sync.write(png)
}

const outDir = path.join(__dirname, '..', 'webview-ui', 'public', 'assets', 'characters')
fs.mkdirSync(outDir, { recursive: true })

for (let i = 0; i < CHARACTER_PALETTES.length; i++) {
  const buffer = buildCharacterPng(i)
  const outPath = path.join(outDir, `char_${i}.png`)
  fs.writeFileSync(outPath, buffer)
  console.log(`✓ Wrote ${outPath} (palette ${i}, ${FRAME_W * FRAMES_PER_ROW}×${FRAME_H * DIRECTIONS.length})`)
}

console.log(`\nGenerated ${CHARACTER_PALETTES.length} character PNGs`)
console.log('\nPNG layout:')
console.log('  336×192 (7 frames × 48px wide, 3 rows × 64px tall)')
console.log('  Row 0: down, Row 1: up, Row 2: right')
console.log('  Sprite data is 24px tall, bottom-aligned in 64px frame (40px padding at top)')
console.log('\nFrame order (per row):')
console.log('  0: walk_1, 1: walk_2, 2: walk_3, 3: type_1, 4: type_2, 5: read_1, 6: read_2')
